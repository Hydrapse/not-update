{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxObjectRestSpread = _interopRequireDefault(require(\"@babel/plugin-syntax-object-rest-spread\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _pluginTransformParameters = require(\"@babel/plugin-transform-parameters\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ZERO_REFS = (() => {\n  const node = _core.types.identifier(\"a\");\n\n  const property = _core.types.objectProperty(_core.types.identifier(\"key\"), node);\n\n  const pattern = _core.types.objectPattern([property]);\n\n  return _core.types.isReferenced(node, property, pattern) ? 1 : 0;\n})();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false,\n    loose = false\n  } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(path, visitor) {\n    path.traverse({\n      Expression(path) {\n        const parentType = path.parent.type;\n\n        if (parentType === \"AssignmentPattern\" && path.key === \"right\" || parentType === \"ObjectProperty\" && path.parent.computed && path.key === \"key\") {\n          path.skip();\n        }\n      },\n\n      RestElement: visitor\n    });\n  }\n\n  function hasSpread(node) {\n    for (const prop of node.properties) {\n      if (_core.types.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function extractNormalizedKeys(path) {\n    const props = path.node.properties;\n    const keys = [];\n    let allLiteral = true;\n\n    for (const prop of props) {\n      if (_core.types.isIdentifier(prop.key) && !prop.computed) {\n        keys.push(_core.types.stringLiteral(prop.key.name));\n      } else if (_core.types.isTemplateLiteral(prop.key)) {\n        keys.push(_core.types.cloneNode(prop.key));\n      } else if (_core.types.isLiteral(prop.key)) {\n        keys.push(_core.types.stringLiteral(String(prop.key.value)));\n      } else {\n        keys.push(_core.types.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n\n    return {\n      keys,\n      allLiteral\n    };\n  }\n\n  function replaceImpureComputedKeys(properties, scope) {\n    const impureComputedPropertyDeclarators = [];\n\n    for (const propPath of properties) {\n      const key = propPath.get(\"key\");\n\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n\n        const declarator = _core.types.variableDeclarator(_core.types.identifier(name), key.node);\n\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(_core.types.identifier(name));\n      }\n    }\n\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path) {\n    const bindings = path.getOuterBindingIdentifierPaths();\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n\n      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {\n        return;\n      }\n\n      bindingParentPath.remove();\n    });\n  }\n\n  function createObjectSpread(path, file, objRef) {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n\n    _core.types.assertRestElement(last.node);\n\n    const restElement = _core.types.cloneNode(last.node);\n\n    last.remove();\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get(\"properties\"), path.scope);\n    const {\n      keys,\n      allLiteral\n    } = extractNormalizedKeys(path);\n\n    if (keys.length === 0) {\n      return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(getExtendsHelper(file), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)])];\n    }\n\n    let keyExpression;\n\n    if (!allLiteral) {\n      keyExpression = _core.types.callExpression(_core.types.memberExpression(_core.types.arrayExpression(keys), _core.types.identifier(\"map\")), [file.addHelper(\"toPropertyKey\")]);\n    } else {\n      keyExpression = _core.types.arrayExpression(keys);\n    }\n\n    return [impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(file.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression])];\n  }\n\n  function replaceRestElement(parentPath, paramPath, container) {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(paramPath.node, uid)]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n\n      paramPath.replaceWith(_core.types.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"proposal-object-rest-spread\",\n    inherits: _pluginSyntaxObjectRestSpread.default,\n    visitor: {\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set();\n        const idsInRestParams = new Set();\n\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        let idInRest = false;\n\n        const IdentifierHandler = function (path, functionScope) {\n          const name = path.node.name;\n\n          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i;\n\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(path, path.scope);\n            } else {\n              param.traverse({\n                \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler\n              }, path.scope);\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(param.parentPath, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);\n\n          (0, _pluginTransformParameters.convertFunctionParams)(path, loose, shouldTransformParam, replaceRestElement);\n        }\n      },\n\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          if (originalPath.node.id.properties.length > 1 && !_core.types.isIdentifier(originalPath.node.init)) {\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, \"ref\");\n            originalPath.insertBefore(_core.types.variableDeclarator(initRef, originalPath.node.init));\n            originalPath.replaceWith(_core.types.variableDeclarator(originalPath.node.id, _core.types.cloneNode(initRef)));\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath = [];\n          let kind;\n          path.findParent(path => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);\n          refPropertyPath.forEach(prop => {\n            const {\n              node\n            } = prop;\n            ref = _core.types.memberExpression(ref, _core.types.cloneNode(node.key), node.computed);\n          });\n          const objectPatternPath = path.findParent(path => path.isObjectPattern());\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(objectPatternPath, file, ref);\n\n          if (loose) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          _core.types.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n          insertionPath.insertAfter(_core.types.variableDeclarator(argument, callExpression));\n          insertionPath = insertionPath.getSibling(insertionPath.key + 1);\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();\n          }\n        });\n      },\n\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        const hasRest = declaration.get(\"declarations\").some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(paramPath.parentPath, paramPath);\n      },\n\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n          const refName = path.scope.generateUidBasedOnNode(path.node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(refName), path.node.right)]));\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(leftPath, file, _core.types.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(_core.types.variableDeclaration(\"var\", impureComputedPropertyDeclarators));\n          }\n\n          const nodeWithoutSpread = _core.types.cloneNode(path.node);\n\n          nodeWithoutSpread.right = _core.types.identifier(refName);\n          nodes.push(_core.types.expressionStatement(nodeWithoutSpread));\n          nodes.push(_core.types.toStatement(_core.types.assignmentExpression(\"=\", argument, callExpression)));\n          nodes.push(_core.types.expressionStatement(_core.types.identifier(refName)));\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, _core.types.cloneNode(temp))));\n        } else {\n          const pattern = left.declarations[0].id;\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n          path.ensureBlock();\n          node.body.body.unshift(_core.types.variableDeclaration(node.left.kind, [_core.types.variableDeclarator(pattern, _core.types.cloneNode(key))]));\n        }\n      },\n\n      ArrayPattern(path) {\n        const objectPatterns = [];\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(_core.types.variableDeclarator(objectPattern.node, uid));\n          objectPattern.replaceWith(_core.types.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          statementPath.insertAfter(_core.types.variableDeclaration(statementPath.node.kind || \"var\", objectPatterns));\n        }\n      },\n\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n        const args = [];\n        let props = [];\n\n        function push() {\n          args.push(_core.types.objectExpression(props));\n          props = [];\n        }\n\n        for (const prop of path.node.properties) {\n          if (_core.types.isSpreadElement(prop)) {\n            push();\n            args.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) {\n          push();\n        }\n\n        let helper;\n\n        if (loose) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch (_unused) {\n            this.file.declarations[\"objectSpread2\"] = null;\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n\n        path.replaceWith(_core.types.callExpression(helper, args));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}