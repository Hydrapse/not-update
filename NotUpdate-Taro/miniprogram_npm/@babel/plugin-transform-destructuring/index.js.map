{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false,\n    useBuiltIns = false\n  } = options;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(`.loose must be a boolean or undefined`);\n  }\n\n  const arrayOnlySpread = loose;\n\n  function getExtendsHelper(file) {\n    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n\n  function variableDeclarationHasPattern(node) {\n    for (const declar of node.declarations) {\n      if (_core.types.isPattern(declar.id)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasRest(pattern) {\n    for (const elem of pattern.elements) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function hasObjectRest(pattern) {\n    for (const elem of pattern.properties) {\n      if (_core.types.isRestElement(elem)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const STOP_TRAVERSAL = {};\n\n  const arrayUnpackVisitor = (node, ancestors, state) => {\n    if (!ancestors.length) {\n      return;\n    }\n\n    if (_core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {\n      state.deopt = true;\n      throw STOP_TRAVERSAL;\n    }\n  };\n\n  class DestructuringTransformer {\n    constructor(opts) {\n      this.blockHoist = opts.blockHoist;\n      this.operator = opts.operator;\n      this.arrays = {};\n      this.nodes = opts.nodes || [];\n      this.scope = opts.scope;\n      this.kind = opts.kind;\n      this.arrayOnlySpread = opts.arrayOnlySpread;\n      this.addHelper = opts.addHelper;\n    }\n\n    buildVariableAssignment(id, init) {\n      let op = this.operator;\n      if (_core.types.isMemberExpression(id)) op = \"=\";\n      let node;\n\n      if (op) {\n        node = _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n      } else {\n        node = _core.types.variableDeclaration(this.kind, [_core.types.variableDeclarator(id, _core.types.cloneNode(init))]);\n      }\n\n      node._blockHoist = this.blockHoist;\n      return node;\n    }\n\n    buildVariableDeclaration(id, init) {\n      const declar = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init))]);\n\n      declar._blockHoist = this.blockHoist;\n      return declar;\n    }\n\n    push(id, _init) {\n      const init = _core.types.cloneNode(_init);\n\n      if (_core.types.isObjectPattern(id)) {\n        this.pushObjectPattern(id, init);\n      } else if (_core.types.isArrayPattern(id)) {\n        this.pushArrayPattern(id, init);\n      } else if (_core.types.isAssignmentPattern(id)) {\n        this.pushAssignmentPattern(id, init);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(id, init));\n      }\n    }\n\n    toArray(node, count) {\n      if (this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name]) {\n        return node;\n      } else {\n        return this.scope.toArray(node, count);\n      }\n    }\n\n    pushAssignmentPattern({\n      left,\n      right\n    }, valueRef) {\n      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n      const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression(\"===\", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));\n\n      if (_core.types.isPattern(left)) {\n        let patternId;\n        let node;\n\n        if (this.kind === \"const\" || this.kind === \"let\") {\n          patternId = this.scope.generateUidIdentifier(tempId.name);\n          node = this.buildVariableDeclaration(patternId, tempConditional);\n        } else {\n          patternId = tempId;\n          node = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(tempId), tempConditional));\n        }\n\n        this.nodes.push(node);\n        this.push(left, patternId);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n      }\n    }\n\n    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n      const keys = [];\n      let allLiteral = true;\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (i >= spreadPropIndex) break;\n        if (_core.types.isRestElement(prop)) continue;\n        const key = prop.key;\n\n        if (_core.types.isIdentifier(key) && !prop.computed) {\n          keys.push(_core.types.stringLiteral(key.name));\n        } else if (_core.types.isTemplateLiteral(prop.key)) {\n          keys.push(_core.types.cloneNode(prop.key));\n        } else if (_core.types.isLiteral(key)) {\n          keys.push(_core.types.stringLiteral(String(key.value)));\n        } else {\n          keys.push(_core.types.cloneNode(key));\n          allLiteral = false;\n        }\n      }\n\n      let value;\n\n      if (keys.length === 0) {\n        value = _core.types.callExpression(getExtendsHelper(this), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)]);\n      } else {\n        let keyExpression = _core.types.arrayExpression(keys);\n\n        if (!allLiteral) {\n          keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier(\"map\")), [this.addHelper(\"toPropertyKey\")]);\n        }\n\n        value = _core.types.callExpression(this.addHelper(`objectWithoutProperties${loose ? \"Loose\" : \"\"}`), [_core.types.cloneNode(objRef), keyExpression]);\n      }\n\n      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n    }\n\n    pushObjectProperty(prop, propRef) {\n      if (_core.types.isLiteral(prop.key)) prop.computed = true;\n      const pattern = prop.value;\n\n      const objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);\n\n      if (_core.types.isPattern(pattern)) {\n        this.push(pattern, objRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n      }\n    }\n\n    pushObjectPattern(pattern, objRef) {\n      if (!pattern.properties.length) {\n        this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [objRef])));\n      }\n\n      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n        this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n        objRef = temp;\n      }\n\n      if (hasObjectRest(pattern)) {\n        let copiedPattern;\n\n        for (let i = 0; i < pattern.properties.length; i++) {\n          const prop = pattern.properties[i];\n\n          if (_core.types.isRestElement(prop)) {\n            break;\n          }\n\n          const key = prop.key;\n\n          if (prop.computed && !this.scope.isPure(key)) {\n            const name = this.scope.generateUidIdentifierBasedOnNode(key);\n            this.nodes.push(this.buildVariableDeclaration(name, key));\n\n            if (!copiedPattern) {\n              copiedPattern = pattern = Object.assign({}, pattern, {\n                properties: pattern.properties.slice()\n              });\n            }\n\n            copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {\n              key: name\n            });\n          }\n        }\n      }\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n\n        if (_core.types.isRestElement(prop)) {\n          this.pushObjectRest(pattern, objRef, prop, i);\n        } else {\n          this.pushObjectProperty(prop, objRef);\n        }\n      }\n    }\n\n    canUnpackArrayPattern(pattern, arr) {\n      if (!_core.types.isArrayExpression(arr)) return false;\n      if (pattern.elements.length > arr.elements.length) return;\n\n      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {\n        return false;\n      }\n\n      for (const elem of pattern.elements) {\n        if (!elem) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      for (const elem of arr.elements) {\n        if (_core.types.isSpreadElement(elem)) return false;\n        if (_core.types.isCallExpression(elem)) return false;\n        if (_core.types.isMemberExpression(elem)) return false;\n      }\n\n      const bindings = _core.types.getBindingIdentifiers(pattern);\n\n      const state = {\n        deopt: false,\n        bindings\n      };\n\n      try {\n        _core.types.traverse(arr, arrayUnpackVisitor, state);\n      } catch (e) {\n        if (e !== STOP_TRAVERSAL) throw e;\n      }\n\n      return !state.deopt;\n    }\n\n    pushUnpackedArrayPattern(pattern, arr) {\n      for (let i = 0; i < pattern.elements.length; i++) {\n        const elem = pattern.elements[i];\n\n        if (_core.types.isRestElement(elem)) {\n          this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i)));\n        } else {\n          this.push(elem, arr.elements[i]);\n        }\n      }\n    }\n\n    pushArrayPattern(pattern, arrayRef) {\n      if (!pattern.elements) return;\n\n      if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n        return this.pushUnpackedArrayPattern(pattern, arrayRef);\n      }\n\n      const count = !hasRest(pattern) && pattern.elements.length;\n      const toArray = this.toArray(arrayRef, count);\n\n      if (_core.types.isIdentifier(toArray)) {\n        arrayRef = toArray;\n      } else {\n        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n        this.arrays[arrayRef.name] = true;\n        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n      }\n\n      for (let i = 0; i < pattern.elements.length; i++) {\n        let elem = pattern.elements[i];\n        if (!elem) continue;\n        let elemRef;\n\n        if (_core.types.isRestElement(elem)) {\n          elemRef = this.toArray(arrayRef);\n          elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier(\"slice\")), [_core.types.numericLiteral(i)]);\n          elem = elem.argument;\n        } else {\n          elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), true);\n        }\n\n        this.push(elem, elemRef);\n      }\n    }\n\n    init(pattern, ref) {\n      if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {\n        const memo = this.scope.maybeGenerateMemoised(ref, true);\n\n        if (memo) {\n          this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref)));\n          ref = memo;\n        }\n      }\n\n      this.push(pattern, ref);\n      return this.nodes;\n    }\n\n  }\n\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {\n          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n\n        if (_core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n\n          if (node.body.body.length === 0 && path.isCompletionRecord()) {\n            node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, temp)));\n          return;\n        }\n\n        if (!_core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!_core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        path.ensureBlock();\n        const block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause({\n        node,\n        scope\n      }) {\n        const pattern = node.param;\n        if (!_core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (!_core.types.isPattern(node.left)) return;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          operator: node.operator,\n          scope: scope,\n          nodes: nodes,\n          arrayOnlySpread,\n          addHelper: name => this.addHelper(name)\n        });\n        let ref;\n\n        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n          ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n          nodes.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(ref, node.right)]));\n\n          if (_core.types.isArrayExpression(node.right)) {\n            destructuring.arrays[ref.name] = true;\n          }\n        }\n\n        destructuring.init(node.left, ref || node.right);\n\n        if (ref) {\n          if (path.parentPath.isArrowFunctionExpression()) {\n            path.replaceWith(_core.types.blockStatement([]));\n            nodes.push(_core.types.returnStatement(_core.types.cloneNode(ref)));\n          } else {\n            nodes.push(_core.types.expressionStatement(_core.types.cloneNode(ref)));\n          }\n        }\n\n        path.replaceWithMultiple(nodes);\n        path.scope.crawl();\n      },\n\n      VariableDeclaration(path) {\n        const {\n          node,\n          scope,\n          parent\n        } = path;\n        if (_core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        const nodeKind = node.kind;\n        const nodes = [];\n        let declar;\n\n        for (let i = 0; i < node.declarations.length; i++) {\n          declar = node.declarations[i];\n          const patternId = declar.init;\n          const pattern = declar.id;\n          const destructuring = new DestructuringTransformer({\n            blockHoist: node._blockHoist,\n            nodes: nodes,\n            scope: scope,\n            kind: node.kind,\n            arrayOnlySpread,\n            addHelper: name => this.addHelper(name)\n          });\n\n          if (_core.types.isPattern(pattern)) {\n            destructuring.init(pattern, patternId);\n\n            if (+i !== node.declarations.length - 1) {\n              _core.types.inherits(nodes[nodes.length - 1], declar);\n            }\n          } else {\n            nodes.push(_core.types.inherits(destructuring.buildVariableAssignment(declar.id, _core.types.cloneNode(declar.init)), declar));\n          }\n        }\n\n        let tail = null;\n        const nodesOut = [];\n\n        for (const node of nodes) {\n          if (tail !== null && _core.types.isVariableDeclaration(node)) {\n            tail.declarations.push(...node.declarations);\n          } else {\n            node.kind = nodeKind;\n            nodesOut.push(node);\n            tail = _core.types.isVariableDeclaration(node) ? node : null;\n          }\n        }\n\n        for (const nodeOut of nodesOut) {\n          if (!nodeOut.declarations) continue;\n\n          for (const declaration of nodeOut.declarations) {\n            const {\n              name\n            } = declaration.id;\n\n            if (scope.bindings[name]) {\n              scope.bindings[name].kind = nodeOut.kind;\n            }\n          }\n        }\n\n        if (nodesOut.length === 1) {\n          path.replaceWith(nodesOut[0]);\n        } else {\n          path.replaceWithMultiple(nodesOut);\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}