{"version":3,"sources":["index.js","fields.js","typescript.js","decorators.js","misc.js","features.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;ACFA,AENA,AJYA,ADGA,AIZA,AFMA;AIXA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;AELA,AHSA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AENA,AJYA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA,AIZA;ADIA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;AGRA,AFMA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar _fields = require(\"./fields\");\n\nvar _decorators = require(\"./decorators\");\n\nvar _misc = require(\"./misc\");\n\nvar _features = require(\"./features\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\nfunction createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions\n}) {\n  return {\n    name,\n    manipulateOptions,\n\n    pre() {\n      (0, _features.enableFeature)(this.file, feature, loose);\n\n      if (!this.file.get(versionKey) || this.file.get(versionKey) < version) {\n        this.file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, state) {\n        if (this.file.get(versionKey) !== version) return;\n        (0, _features.verifyUsedFeatures)(path, this.file);\n        const loose = (0, _features.isLoose)(this.file, feature);\n        let constructor;\n        let isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          (0, _features.verifyUsedFeatures)(path, this.file);\n\n          if (path.node.computed) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.node.kind === \"get\") {\n              if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(getName).add(name);\n            } else if (path.node.kind === \"set\") {\n              if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(setName).add(name);\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n\n            if (path.isProperty() || path.isPrivate()) {\n              props.push(path);\n            }\n          }\n\n          if (!isDecorated) isDecorated = (0, _decorators.hasOwnDecorators)(path.node);\n        }\n\n        if (!props.length && !isDecorated) return;\n        let ref;\n\n        if (path.isClassExpression() || !path.node.id) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = path.node.id;\n        }\n\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, loose, state);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, loose, state);\n        let keysNodes, staticNodes, instanceNodes, wrapClass;\n\n        if (isDecorated) {\n          staticNodes = keysNodes = [];\n          ({\n            instanceNodes,\n            wrapClass\n          } = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file));\n        } else {\n          keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file);\n          ({\n            staticNodes,\n            instanceNodes,\n            wrapClass\n          } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, loose));\n        }\n\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            if (isDecorated) return;\n\n            for (const prop of props) {\n              if (prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n\n        path = wrapClass(path);\n        path.insertBefore(keysNodes);\n        path.insertAfter([...privateNamesNodes, ...staticNodes]);\n      },\n\n      PrivateName(path) {\n        if (this.file.get(versionKey) !== version) return;\n        throw path.buildCodeFrameError(`Unknown PrivateName \"${path}\"`);\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (this.file.get(versionKey) !== version) return;\n        const decl = path.get(\"declaration\");\n\n        if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n          if (decl.node.id) {\n            (0, _helperSplitExportDeclaration.default)(path);\n          } else {\n            decl.node.type = \"ClassExpression\";\n          }\n        }\n      }\n\n    }\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireWildcard(require(\"@babel/helper-replace-supers\"));\n\nvar _helperMemberExpressionToFunctions = _interopRequireDefault(require(\"@babel/helper-member-expression-to-functions\"));\n\nvar _helperOptimiseCallExpression = _interopRequireDefault(require(\"@babel/helper-optimise-call-expression\"));\n\nvar ts = _interopRequireWildcard(require(\"./typescript\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    const isPrivate = prop.isPrivate();\n    const isMethod = !prop.isProperty();\n    const isInstance = !prop.node.static;\n\n    if (isPrivate) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: !isInstance,\n        method: isMethod\n      };\n\n      if (prop.node.kind === \"get\") {\n        update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n      } else if (prop.node.kind === \"set\") {\n        update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n      } else if (prop.node.kind === \"method\") {\n        update.methodId = prop.scope.generateUidIdentifier(name);\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, loose, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    if (loose) {\n      initNodes.push(_core.template.statement.ast`\n          var ${id} = ${state.addHelper(\"classPrivateFieldLooseKey\")}(\"${name}\")\n        `);\n    } else if (isMethod && !isStatic) {\n      if (isAccessor) {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n      } else {\n        initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`);\n      }\n    } else if (!isStatic) {\n      initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);\n    }\n  }\n\n  return initNodes;\n}\n\nconst privateNameVisitor = {\n  PrivateName(path) {\n    const {\n      privateNamesMap\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      property: node\n    })) return;\n    if (!privateNamesMap.has(node.id.name)) return;\n    this.handle(parentPath);\n  },\n\n  Class(path) {\n    const {\n      privateNamesMap\n    } = this;\n    const body = path.get(\"body.body\");\n\n    for (const prop of body) {\n      if (!prop.isPrivate()) {\n        continue;\n      }\n\n      if (!privateNamesMap.has(prop.node.key.id.name)) continue;\n      path.traverse(privateNameInnerVisitor, this);\n      path.skip();\n      break;\n    }\n  }\n\n};\n\nconst privateNameInnerVisitor = _core.traverse.visitors.merge([{\n  PrivateName: privateNameVisitor.PrivateName\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodSet\"), []);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id\n    } = privateNamesMap.get(name);\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  handle(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    member.replaceWith(_core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: object,\n      PROP: privateNamesMap.get(name).id\n    }));\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {\n  const body = path.get(\"body\");\n\n  if (loose) {\n    body.traverse(privateNameVisitor, Object.assign({\n      privateNamesMap,\n      file: state\n    }, privateNameHandlerLoose));\n  } else {\n    (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n      privateNamesMap,\n      classRef: ref,\n      file: state\n    }, privateNameHandlerSpec));\n  }\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`${id}.set(${ref}, {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ${value},\n  })`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${id.name} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${id} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n\n  return _core.template.statement.ast`${id}.add(${ref})`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, loose = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n\n  const methodValue = _core.types.functionExpression(methodId, params, body, generator, async);\n\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(getId, methodValue)]);\n  }\n\n  if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(setId, methodValue)]);\n  }\n\n  if (isStatic && !loose) {\n    return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(id, _core.types.functionExpression(id, params, body, generator, async))]);\n  }\n\n  return _core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(methodId, methodValue)]);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nfunction replaceThisContext(path, ref, superRef, file, loose) {\n  const state = {\n    classRef: ref,\n    needsClassRef: false\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    isLoose: loose,\n    superRef,\n    file,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {\n  const staticNodes = [];\n  const instanceNodes = [];\n  let needsClassRef = false;\n\n  for (const prop of props) {\n    ts.assertFieldTransformed(prop);\n    const isStatic = prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n\n    if (isStatic || isMethod && isPrivate) {\n      const replaced = replaceThisContext(prop, ref, superRef, state, loose);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStatic && isPrivate && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n        break;\n\n      case isStatic && isPublic && isField && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && loose:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !loose:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isMethod && loose:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPrivate && isMethod && !loose:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap));\n        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && !loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isStatic && isPrivate && isMethod && loose:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));\n        break;\n\n      case isInstance && isPublic && isField && loose:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !loose:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertFieldTransformed = assertFieldTransformed;\n\nfunction assertFieldTransformed(path) {\n  if (path.node.declare) {\n    throw path.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by ` + `@babel/plugin-transform-typescript.\\n` + `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` + `that it runs before any plugin related to additional class features:\\n` + ` - @babel/plugin-proposal-class-properties\\n` + ` - @babel/plugin-proposal-private-methods\\n` + ` - @babel/plugin-proposal-decorators`);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasOwnDecorators = hasOwnDecorators;\nexports.hasDecorators = hasDecorators;\nexports.buildDecoratedClass = buildDecoratedClass;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = _interopRequireDefault(require(\"@babel/helper-replace-supers\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasOwnDecorators(node) {\n  return !!(node.decorators && node.decorators.length);\n}\n\nfunction hasDecorators(node) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key, value) {\n  if (!value) return null;\n  return _core.types.objectProperty(_core.types.identifier(key), value);\n}\n\nfunction method(key, body) {\n  return _core.types.objectMethod(\"method\", _core.types.identifier(key), [], _core.types.blockStatement(body));\n}\n\nfunction takeDecorators(node) {\n  let result;\n\n  if (node.decorators && node.decorators.length > 0) {\n    result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression));\n  }\n\n  node.decorators = undefined;\n  return result;\n}\n\nfunction getKey(node) {\n  if (node.computed) {\n    return node.key;\n  } else if (_core.types.isIdentifier(node.key)) {\n    return _core.types.stringLiteral(node.key.name);\n  } else {\n    return _core.types.stringLiteral(String(node.key.value));\n  }\n}\n\nfunction extractElementDescriptor(classRef, superRef, path) {\n  const {\n    node,\n    scope\n  } = path;\n  const isMethod = path.isClassMethod();\n\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(`Private ${isMethod ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n  }\n\n  new _helperReplaceSupers.default({\n    methodPath: path,\n    methodNode: node,\n    objectRef: classRef,\n    isStatic: node.static,\n    superRef,\n    scope,\n    file: this\n  }, true).replace();\n  const properties = [prop(\"kind\", _core.types.stringLiteral(isMethod ? node.kind : \"field\")), prop(\"decorators\", takeDecorators(node)), prop(\"static\", node.static && _core.types.booleanLiteral(true)), prop(\"key\", getKey(node))].filter(Boolean);\n\n  if (isMethod) {\n    const id = node.computed ? null : node.key;\n\n    _core.types.toExpression(node);\n\n    properties.push(prop(\"value\", (0, _helperFunctionName.default)({\n      node,\n      id,\n      scope\n    }) || node));\n  } else if (node.value) {\n    properties.push(method(\"value\", _core.template.statements.ast`return ${node.value}`));\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n  return _core.types.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file) {\n  try {\n    return file.addHelper(\"decorate\");\n  } catch (err) {\n    if (err.code === \"BABEL_HELPER_UNKNOWN\") {\n      err.message += \"\\n  '@babel/plugin-transform-decorators' in non-legacy mode\" + \" requires '@babel/core' version ^7.0.2 and you appear to be using\" + \" an older version.\";\n    }\n\n    throw err;\n  }\n}\n\nfunction buildDecoratedClass(ref, path, elements, file) {\n  const {\n    node,\n    scope\n  } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const {\n    superClass\n  } = node;\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = _core.types.cloneNode(ref);\n  let superId;\n\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n\n  const definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId)));\n\n  let replacement = _core.template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || _core.types.nullLiteral()},\n      function (${initializeId}, ${superClass ? superId : null}) {\n        ${node}\n        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  `;\n  let classPathDesc = \"arguments.1.body.body.0\";\n\n  if (!isStrict) {\n    replacement.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral(\"use strict\")));\n  }\n\n  if (isDeclaration) {\n    replacement = _core.template.ast`let ${ref} = ${replacement}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [_core.template.statement.ast`${initializeId}(this)`],\n\n    wrapClass(path) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc);\n    }\n\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.injectInitialization = injectInitialization;\nexports.extractComputedKeys = extractComputedKeys;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n\n}, _helperReplaceSupers.environmentVisitor]);\n\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path) {\n    if (this.scope.hasOwnBinding(path.node.name)) {\n      this.scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n\n};\n\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\n\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n\n    for (const bareSuper of bareSupers) {\n      bareSuper.insertAfter(nodes);\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nfunction extractComputedKeys(ref, path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableFeature = enableFeature;\nexports.isLoose = isLoose;\nexports.verifyUsedFeatures = verifyUsedFeatures;\nexports.FEATURES = void 0;\n\nvar _decorators = require(\"./decorators\");\n\nconst FEATURES = Object.freeze({\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3\n});\nexports.FEATURES = FEATURES;\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\n\nfunction enableFeature(file, feature, loose) {\n  if (!hasFeature(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n    if (loose) file.set(looseKey, file.get(looseKey) | feature);\n  }\n}\n\nfunction hasFeature(file, feature) {\n  return !!(file.get(featuresKey) & feature);\n}\n\nfunction isLoose(file, feature) {\n  return !!(file.get(looseKey) & feature);\n}\n\nfunction verifyUsedFeatures(path, file) {\n  if ((0, _decorators.hasOwnDecorators)(path.node)) {\n    if (!hasFeature(file, FEATURES.decorators)) {\n      throw path.buildCodeFrameError(\"Decorators are not enabled.\" + \"\\nIf you are using \" + '[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], ' + 'make sure it comes *before* \"@babel/plugin-proposal-class-properties\" ' + \"and enable loose mode, like so:\\n\" + '\\t[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }]\\n' + '\\t[\"@babel/plugin-proposal-class-properties\", { \"loose\": true }]');\n    }\n\n    if (path.isPrivate()) {\n      throw path.buildCodeFrameError(`Private ${path.isClassMethod() ? \"methods\" : \"fields\"} in decorated classes are not supported yet.`);\n    }\n  }\n\n  if (path.isPrivate() && path.isMethod()) {\n    if (!hasFeature(file, FEATURES.privateMethods)) {\n      throw path.buildCodeFrameError(\"Class private methods are not enabled.\");\n    }\n  }\n\n  if (hasFeature(file, FEATURES.privateMethods) && hasFeature(file, FEATURES.fields) && isLoose(file, FEATURES.privateMethods) !== isLoose(file, FEATURES.fields)) {\n    throw path.buildCodeFrameError(\"'loose' mode configuration must be the same for both @babel/plugin-proposal-class-properties \" + \"and @babel/plugin-proposal-private-methods\");\n  }\n\n  if (path.isProperty()) {\n    if (!hasFeature(file, FEATURES.fields)) {\n      throw path.buildCodeFrameError(\"Class fields are not enabled.\");\n    }\n  }\n}","module.exports = {\n  \"name\": \"@babel/helper-create-class-features-plugin\",\n  \"version\": \"7.9.5\",\n  \"author\": \"The Babel Team (https://babeljs.io/team)\",\n  \"license\": \"MIT\",\n  \"description\": \"Compile class public and private fields, private methods and decorators to ES6\",\n  \"repository\": \"https://github.com/babel/babel/tree/master/packages/babel-helper-create-class-features-plugin\",\n  \"main\": \"lib/index.js\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"keywords\": [\n    \"babel\",\n    \"babel-plugin\"\n  ],\n  \"dependencies\": {\n    \"@babel/helper-function-name\": \"^7.9.5\",\n    \"@babel/helper-member-expression-to-functions\": \"^7.8.3\",\n    \"@babel/helper-optimise-call-expression\": \"^7.8.3\",\n    \"@babel/helper-plugin-utils\": \"^7.8.3\",\n    \"@babel/helper-replace-supers\": \"^7.8.6\",\n    \"@babel/helper-split-export-declaration\": \"^7.8.3\"\n  },\n  \"peerDependencies\": {\n    \"@babel/core\": \"^7.0.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.8.6\",\n    \"@babel/helper-plugin-test-runner\": \"^7.8.3\"\n  },\n  \"gitHead\": \"5b97e77e030cf3853a147fdff81844ea4026219d\"\n}\n"]}