{"version":3,"sources":["index.js","transformer-legacy.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxDecorators = _interopRequireDefault(require(\"@babel/plugin-syntax-decorators\"));\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _transformerLegacy = _interopRequireDefault(require(\"./transformer-legacy\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    legacy = false\n  } = options;\n\n  if (typeof legacy !== \"boolean\") {\n    throw new Error(\"'legacy' must be a boolean.\");\n  }\n\n  const {\n    decoratorsBeforeExport\n  } = options;\n\n  if (decoratorsBeforeExport === undefined) {\n    if (!legacy) {\n      throw new Error(\"The decorators plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you want to use the legacy\" + \" decorators semantics, you can set the 'legacy: true' option.\");\n    }\n  } else {\n    if (legacy) {\n      throw new Error(\"'decoratorsBeforeExport' can't be used with legacy decorators.\");\n    }\n\n    if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (legacy) {\n    return {\n      name: \"proposal-decorators\",\n      inherits: _pluginSyntaxDecorators.default,\n\n      manipulateOptions({\n        generatorOpts\n      }) {\n        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n      },\n\n      visitor: _transformerLegacy.default\n    };\n  }\n\n  return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({\n    name: \"proposal-decorators\",\n    feature: _helperCreateClassFeaturesPlugin.FEATURES.decorators,\n\n    manipulateOptions({\n      generatorOpts,\n      parserOpts\n    }) {\n      parserOpts.plugins.push([\"decorators\", {\n        decoratorsBeforeExport\n      }]);\n      generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;\n    }\n\n  });\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nconst buildClassDecorator = (0, _core.template)(`\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n`);\nconst buildClassPrototype = (0, _core.template)(`\n  CLASS_REF.prototype;\n`);\nconst buildGetDescriptor = (0, _core.template)(`\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n`);\nconst buildGetObjectInitializer = (0, _core.template)(`\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n`);\nconst WARNING_CALLS = new WeakSet();\n\nfunction applyEnsureOrdering(path) {\n  const decorators = (path.isClass() ? [path].concat(path.get(\"body.body\")) : path.get(\"properties\")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []);\n  const identDecorators = decorators.filter(decorator => !_core.types.isIdentifier(decorator.expression));\n  if (identDecorators.length === 0) return;\n  return _core.types.sequenceExpression(identDecorators.map(decorator => {\n    const expression = decorator.expression;\n    const id = decorator.expression = path.scope.generateDeclaredUidIdentifier(\"dec\");\n    return _core.types.assignmentExpression(\"=\", id, expression);\n  }).concat([path.node]));\n}\n\nfunction applyClassDecorators(classPath) {\n  if (!hasClassDecorators(classPath.node)) return;\n  const decorators = classPath.node.decorators || [];\n  classPath.node.decorators = null;\n  const name = classPath.scope.generateDeclaredUidIdentifier(\"class\");\n  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {\n    return buildClassDecorator({\n      CLASS_REF: _core.types.cloneNode(name),\n      DECORATOR: _core.types.cloneNode(decorator),\n      INNER: acc\n    }).expression;\n  }, classPath.node);\n}\n\nfunction hasClassDecorators(classNode) {\n  return !!(classNode.decorators && classNode.decorators.length);\n}\n\nfunction applyMethodDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.body.body)) return;\n  return applyTargetDecorators(path, state, path.node.body.body);\n}\n\nfunction hasMethodDecorators(body) {\n  return body.some(node => node.decorators && node.decorators.length);\n}\n\nfunction applyObjectDecorators(path, state) {\n  if (!hasMethodDecorators(path.node.properties)) return;\n  return applyTargetDecorators(path, state, path.node.properties);\n}\n\nfunction applyTargetDecorators(path, state, decoratedProps) {\n  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? \"class\" : \"obj\");\n  const exprs = decoratedProps.reduce(function (acc, node) {\n    const decorators = node.decorators || [];\n    node.decorators = null;\n    if (decorators.length === 0) return acc;\n\n    if (node.computed) {\n      throw path.buildCodeFrameError(\"Computed method/property decorators are not yet supported.\");\n    }\n\n    const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name);\n    const target = path.isClass() && !node.static ? buildClassPrototype({\n      CLASS_REF: name\n    }).expression : name;\n\n    if (_core.types.isClassProperty(node, {\n      static: false\n    })) {\n      const descriptor = path.scope.generateDeclaredUidIdentifier(\"descriptor\");\n      const initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();\n      node.value = _core.types.callExpression(state.addHelper(\"initializerWarningHelper\"), [descriptor, _core.types.thisExpression()]);\n      WARNING_CALLS.add(node.value);\n      acc = acc.concat([_core.types.assignmentExpression(\"=\", descriptor, _core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"configurable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"enumerable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"writable\"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier(\"initializer\"), initializer)])]))]);\n    } else {\n      acc = acc.concat(_core.types.callExpression(state.addHelper(\"applyDecoratedDescriptor\"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map(dec => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, {\n        static: true\n      }) ? buildGetObjectInitializer({\n        TEMP: path.scope.generateDeclaredUidIdentifier(\"init\"),\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression : buildGetDescriptor({\n        TARGET: _core.types.cloneNode(target),\n        PROPERTY: _core.types.cloneNode(property)\n      }).expression, _core.types.cloneNode(target)]));\n    }\n\n    return acc;\n  }, []);\n  return _core.types.sequenceExpression([_core.types.assignmentExpression(\"=\", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);\n}\n\nfunction decoratedClassToExpression({\n  node,\n  scope\n}) {\n  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {\n    return;\n  }\n\n  const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier(\"class\");\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);\n}\n\nvar _default = {\n  ExportDefaultDeclaration(path) {\n    const decl = path.get(\"declaration\");\n    if (!decl.isClassDeclaration()) return;\n    const replacement = decoratedClassToExpression(decl);\n\n    if (replacement) {\n      const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier(\"default\"))])]);\n\n      if (!decl.node.id) {\n        path.scope.registerDeclaration(varDeclPath);\n      }\n    }\n  },\n\n  ClassDeclaration(path) {\n    const replacement = decoratedClassToExpression(path);\n\n    if (replacement) {\n      path.replaceWith(replacement);\n    }\n  },\n\n  ClassExpression(path, state) {\n    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path, state) || applyMethodDecorators(path, state);\n    if (decoratedClass) path.replaceWith(decoratedClass);\n  },\n\n  ObjectExpression(path, state) {\n    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);\n    if (decoratedObject) path.replaceWith(decoratedObject);\n  },\n\n  AssignmentExpression(path, state) {\n    if (!WARNING_CALLS.has(path.node.right)) return;\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"left.object\").node), _core.types.stringLiteral(path.get(\"left.property\").node.name || path.get(\"left.property\").node.value), _core.types.cloneNode(path.get(\"right.arguments\")[0].node), _core.types.cloneNode(path.get(\"right.arguments\")[1].node)]));\n  },\n\n  CallExpression(path, state) {\n    if (path.node.arguments.length !== 3) return;\n    if (!WARNING_CALLS.has(path.node.arguments[2])) return;\n\n    if (path.node.callee.name !== state.addHelper(\"defineProperty\").name) {\n      return;\n    }\n\n    path.replaceWith(_core.types.callExpression(state.addHelper(\"initializerDefineProperty\"), [_core.types.cloneNode(path.get(\"arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments\")[1].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[0].node), _core.types.cloneNode(path.get(\"arguments.2.arguments\")[1].node)]));\n  }\n\n};\nexports.default = _default;"]}