{"version":3,"sources":["index.js","features.js","util.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\n\nvar _regexpuCore = _interopRequireDefault(require(\"regexpu-core\"));\n\nvar _features = require(\"./features\");\n\nvar _util = require(\"./util\");\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperRegex = require(\"@babel/helper-regex\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst version = _package.default.version.split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\n\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nfunction createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {}\n}) {\n  return {\n    name,\n\n    pre() {\n      var _file$get;\n\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime = true\n      } = options;\n\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n\n      if (!runtime) {\n        file.set(_features.runtimeKey, false);\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node, features);\n\n        if (regexpuOptions === null) {\n          return;\n        }\n\n        const namedCaptureGroups = {};\n\n        if (regexpuOptions.namedGroup) {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            namedCaptureGroups[name] = index;\n          };\n        }\n\n        node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions);\n\n        if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"u\");\n        }\n\n        if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag)) {\n          (0, _helperRegex.pullFlag)(node, \"s\");\n        }\n      }\n\n    }\n  };\n}\n\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableFeature = enableFeature;\nexports.hasFeature = hasFeature;\nexports.runtimeKey = exports.featuresKey = exports.FEATURES = void 0;\nconst FEATURES = Object.freeze({\n  unicodeFlag: 1 << 0,\n  dotAllFlag: 1 << 1,\n  unicodePropertyEscape: 1 << 2,\n  namedCaptureGroups: 1 << 3\n});\nexports.FEATURES = FEATURES;\nconst featuresKey = \"@babel/plugin-regexp-features/featuresKey\";\nexports.featuresKey = featuresKey;\nconst runtimeKey = \"@babel/plugin-regexp-features/runtimeKey\";\nexports.runtimeKey = runtimeKey;\n\nfunction enableFeature(features, feature) {\n  return features | feature;\n}\n\nfunction hasFeature(features, feature) {\n  return !!(features & feature);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateRegexpuOptions = generateRegexpuOptions;\n\nvar _features = require(\"./features\");\n\nfunction generateRegexpuOptions(node, features) {\n  let useUnicodeFlag = false,\n      dotAllFlag = false,\n      unicodePropertyEscape = false,\n      namedGroup = false;\n  const {\n    flags,\n    pattern\n  } = node;\n  const flagsIncludesU = flags.includes(\"u\");\n\n  if (flagsIncludesU) {\n    if (!(0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag)) {\n      useUnicodeFlag = true;\n    }\n\n    if ((0, _features.hasFeature)(features, _features.FEATURES.unicodePropertyEscape) && /\\\\[pP]{/.test(pattern)) {\n      unicodePropertyEscape = true;\n    }\n  }\n\n  if ((0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag) && flags.indexOf(\"s\") >= 0) {\n    dotAllFlag = true;\n  }\n\n  if ((0, _features.hasFeature)(features, _features.FEATURES.namedCaptureGroups) && /\\(\\?<(?![=!])/.test(pattern)) {\n    namedGroup = true;\n  }\n\n  if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {\n    return null;\n  }\n\n  if (flagsIncludesU && flags.indexOf(\"s\") >= 0) {\n    dotAllFlag = true;\n  }\n\n  return {\n    useUnicodeFlag,\n    onNamedGroup: () => {},\n    namedGroup,\n    unicodePropertyEscape,\n    dotAllFlag,\n    lookbehind: true\n  };\n}","module.exports = {\n  \"name\": \"@babel/helper-create-regexp-features-plugin\",\n  \"version\": \"7.8.8\",\n  \"author\": \"The Babel Team (https://babeljs.io/team)\",\n  \"license\": \"MIT\",\n  \"description\": \"Compile ESNext Regular Expressions to ES5\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/babel/babel\",\n    \"directory\": \"packages/babel-helper-create-regexp-features-plugin\"\n  },\n  \"main\": \"lib/index.js\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"keywords\": [\n    \"babel\",\n    \"babel-plugin\"\n  ],\n  \"dependencies\": {\n    \"@babel/helper-annotate-as-pure\": \"^7.8.3\",\n    \"@babel/helper-regex\": \"^7.8.3\",\n    \"regexpu-core\": \"^4.7.0\"\n  },\n  \"peerDependencies\": {\n    \"@babel/core\": \"^7.0.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.8.6\",\n    \"@babel/helper-plugin-test-runner\": \"^7.8.3\"\n  },\n  \"gitHead\": \"c831a2450dbf252c75750a455c63e1016c2f2244\"\n}\n"]}